// screen.c - screen management routines
// Copyright (C) 2019 Megan Ruggiero. All rights reserved.
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#include <err.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "screen.h"
#include "unifont.h"

#define pdie(message) (err(EXIT_FAILURE, "%s", message))

static const struct color default_palette[256] = {
	{0x00,0x00,0x00},{0x80,0x00,0x00},{0x00,0x80,0x00},{0x80,0x80,0x00},
	{0x00,0x00,0x80},{0x80,0x00,0x80},{0x00,0x80,0x80},{0xC0,0xC0,0xC0},
	{0x80,0x80,0x80},{0xFF,0x00,0x00},{0x00,0xFF,0x00},{0xFF,0xFF,0x00},
	{0x00,0x00,0xFF},{0xFF,0x00,0xFF},{0x00,0xFF,0xFF},{0xFF,0xFF,0xFF},
	{0x00,0x00,0x00},{0x00,0x00,0x5F},{0x00,0x00,0x87},{0x00,0x00,0xAF},
	{0x00,0x00,0xD7},{0x00,0x00,0xFF},{0x00,0x5F,0x00},{0x00,0x5F,0x5F},
	{0x00,0x5F,0x87},{0x00,0x5F,0xAF},{0x00,0x5F,0xD7},{0x00,0x5F,0xFF},
	{0x00,0x87,0x00},{0x00,0x87,0x5F},{0x00,0x87,0x87},{0x00,0x87,0xAF},
	{0x00,0x87,0xD7},{0x00,0x87,0xFF},{0x00,0xAF,0x00},{0x00,0xAF,0x5F},
	{0x00,0xAF,0x87},{0x00,0xAF,0xAF},{0x00,0xAF,0xD7},{0x00,0xAF,0xFF},
	{0x00,0xD7,0x00},{0x00,0xD7,0x5F},{0x00,0xD7,0x87},{0x00,0xD7,0xAF},
	{0x00,0xD7,0xD7},{0x00,0xD7,0xFF},{0x00,0xFF,0x00},{0x00,0xFF,0x5F},
	{0x00,0xFF,0x87},{0x00,0xFF,0xAF},{0x00,0xFF,0xD7},{0x00,0xFF,0xFF},
	{0x5F,0x00,0x00},{0x5F,0x00,0x5F},{0x5F,0x00,0x87},{0x5F,0x00,0xAF},
	{0x5F,0x00,0xD7},{0x5F,0x00,0xFF},{0x5F,0x5F,0x00},{0x5F,0x5F,0x5F},
	{0x5F,0x5F,0x87},{0x5F,0x5F,0xAF},{0x5F,0x5F,0xD7},{0x5F,0x5F,0xFF},
	{0x5F,0x87,0x00},{0x5F,0x87,0x5F},{0x5F,0x87,0x87},{0x5F,0x87,0xAF},
	{0x5F,0x87,0xD7},{0x5F,0x87,0xFF},{0x5F,0xAF,0x00},{0x5F,0xAF,0x5F},
	{0x5F,0xAF,0x87},{0x5F,0xAF,0xAF},{0x5F,0xAF,0xD7},{0x5F,0xAF,0xFF},
	{0x5F,0xD7,0x00},{0x5F,0xD7,0x5F},{0x5F,0xD7,0x87},{0x5F,0xD7,0xAF},
	{0x5F,0xD7,0xD7},{0x5F,0xD7,0xFF},{0x5F,0xFF,0x00},{0x5F,0xFF,0x5F},
	{0x5F,0xFF,0x87},{0x5F,0xFF,0xAF},{0x5F,0xFF,0xD7},{0x5F,0xFF,0xFF},
	{0x87,0x00,0x00},{0x87,0x00,0x5F},{0x87,0x00,0x87},{0x87,0x00,0xAF},
	{0x87,0x00,0xD7},{0x87,0x00,0xFF},{0x87,0x5F,0x00},{0x87,0x5F,0x5F},
	{0x87,0x5F,0x87},{0x87,0x5F,0xAF},{0x87,0x5F,0xD7},{0x87,0x5F,0xFF},
	{0x87,0x87,0x00},{0x87,0x87,0x5F},{0x87,0x87,0x87},{0x87,0x87,0xAF},
	{0x87,0x87,0xD7},{0x87,0x87,0xFF},{0x87,0xAF,0x00},{0x87,0xAF,0x5F},
	{0x87,0xAF,0x87},{0x87,0xAF,0xAF},{0x87,0xAF,0xD7},{0x87,0xAF,0xFF},
	{0x87,0xD7,0x00},{0x87,0xD7,0x5F},{0x87,0xD7,0x87},{0x87,0xD7,0xAF},
	{0x87,0xD7,0xD7},{0x87,0xD7,0xFF},{0x87,0xFF,0x00},{0x87,0xFF,0x5F},
	{0x87,0xFF,0x87},{0x87,0xFF,0xAF},{0x87,0xFF,0xD7},{0x87,0xFF,0xFF},
	{0xAF,0x00,0x00},{0xAF,0x00,0x5F},{0xAF,0x00,0x87},{0xAF,0x00,0xAF},
	{0xAF,0x00,0xD7},{0xAF,0x00,0xFF},{0xAF,0x5F,0x00},{0xAF,0x5F,0x5F},
	{0xAF,0x5F,0x87},{0xAF,0x5F,0xAF},{0xAF,0x5F,0xD7},{0xAF,0x5F,0xFF},
	{0xAF,0x87,0x00},{0xAF,0x87,0x5F},{0xAF,0x87,0x87},{0xAF,0x87,0xAF},
	{0xAF,0x87,0xD7},{0xAF,0x87,0xFF},{0xAF,0xAF,0x00},{0xAF,0xAF,0x5F},
	{0xAF,0xAF,0x87},{0xAF,0xAF,0xAF},{0xAF,0xAF,0xD7},{0xAF,0xAF,0xFF},
	{0xAF,0xD7,0x00},{0xAF,0xD7,0x5F},{0xAF,0xD7,0x87},{0xAF,0xD7,0xAF},
	{0xAF,0xD7,0xD7},{0xAF,0xD7,0xFF},{0xAF,0xFF,0x00},{0xAF,0xFF,0x5F},
	{0xAF,0xFF,0x87},{0xAF,0xFF,0xAF},{0xAF,0xFF,0xD7},{0xAF,0xFF,0xFF},
	{0xD7,0x00,0x00},{0xD7,0x00,0x5F},{0xD7,0x00,0x87},{0xD7,0x00,0xAF},
	{0xD7,0x00,0xD7},{0xD7,0x00,0xFF},{0xD7,0x5F,0x00},{0xD7,0x5F,0x5F},
	{0xD7,0x5F,0x87},{0xD7,0x5F,0xAF},{0xD7,0x5F,0xD7},{0xD7,0x5F,0xFF},
	{0xD7,0x87,0x00},{0xD7,0x87,0x5F},{0xD7,0x87,0x87},{0xD7,0x87,0xAF},
	{0xD7,0x87,0xD7},{0xD7,0x87,0xFF},{0xD7,0xAF,0x00},{0xD7,0xAF,0x5F},
	{0xD7,0xAF,0x87},{0xD7,0xAF,0xAF},{0xD7,0xAF,0xD7},{0xD7,0xAF,0xFF},
	{0xD7,0xD7,0x00},{0xD7,0xD7,0x5F},{0xD7,0xD7,0x87},{0xD7,0xD7,0xAF},
	{0xD7,0xD7,0xD7},{0xD7,0xD7,0xFF},{0xD7,0xFF,0x00},{0xD7,0xFF,0x5F},
	{0xD7,0xFF,0x87},{0xD7,0xFF,0xAF},{0xD7,0xFF,0xD7},{0xD7,0xFF,0xFF},
	{0xFF,0x00,0x00},{0xFF,0x00,0x5F},{0xFF,0x00,0x87},{0xFF,0x00,0xAF},
	{0xFF,0x00,0xD7},{0xFF,0x00,0xFF},{0xFF,0x5F,0x00},{0xFF,0x5F,0x5F},
	{0xFF,0x5F,0x87},{0xFF,0x5F,0xAF},{0xFF,0x5F,0xD7},{0xFF,0x5F,0xFF},
	{0xFF,0x87,0x00},{0xFF,0x87,0x5F},{0xFF,0x87,0x87},{0xFF,0x87,0xAF},
	{0xFF,0x87,0xD7},{0xFF,0x87,0xFF},{0xFF,0xAF,0x00},{0xFF,0xAF,0x5F},
	{0xFF,0xAF,0x87},{0xFF,0xAF,0xAF},{0xFF,0xAF,0xD7},{0xFF,0xAF,0xFF},
	{0xFF,0xD7,0x00},{0xFF,0xD7,0x5F},{0xFF,0xD7,0x87},{0xFF,0xD7,0xAF},
	{0xFF,0xD7,0xD7},{0xFF,0xD7,0xFF},{0xFF,0xFF,0x00},{0xFF,0xFF,0x5F},
	{0xFF,0xFF,0x87},{0xFF,0xFF,0xAF},{0xFF,0xFF,0xD7},{0xFF,0xFF,0xFF},
	{0x08,0x08,0x08},{0x12,0x12,0x12},{0x1C,0x1C,0x1C},{0x26,0x26,0x26},
	{0x30,0x30,0x30},{0x3A,0x3A,0x3A},{0x44,0x44,0x44},{0x4E,0x4E,0x4E},
	{0x58,0x58,0x58},{0x62,0x62,0x62},{0x6C,0x6C,0x6C},{0x76,0x76,0x76},
	{0x80,0x80,0x80},{0x8A,0x8A,0x8A},{0x94,0x94,0x94},{0x9E,0x9E,0x9E},
	{0xA8,0xA8,0xA8},{0xB2,0xB2,0xB2},{0xBC,0xBC,0xBC},{0xC6,0xC6,0xC6},
	{0xD0,0xD0,0xD0},{0xDA,0xDA,0xDA},{0xE4,0xE4,0xE4},{0xEE,0xEE,0xEE}
};

const struct cell default_attrs = {
	.background = {0, 0, 0},
	.foreground = {7, 0, 0}
};

struct color palette[256];
bool mode[MODE_COUNT];
struct cursor cursor, saved_cursor;
bool *tabstops;
struct line **lines;
short screen_width, screen_height, scroll_top, scroll_bottom;

void
deinit_screen()
{
	int i;

	for (i = 0; i < screen_height; i++)
		free(lines[i]);

	free(lines);
	free(tabstops);
}

void
resize(int width, int height)
{
	int i;

	deinit_screen();

	if (!(tabstops = calloc(width, sizeof(bool))))
		pdie("failed to allocate tab stop memory");

	for (i = 8; i < width; i += 8)
		tabstops[i] = true;

	if (!(lines = calloc(height, sizeof(struct line *))))
		pdie("failed to allocate line array memory");

	for (i = 0; i < height; i++)
		if (!(lines[i] = calloc(LINE_SIZE(width), 1)))
			pdie("failed to allocate line memory");

	screen_width = width;
	screen_height = height;
	scroll_top = 0;
	scroll_bottom = height - 1;
	cursor.x = 0;
	cursor.y = 0;
}

void
reset()
{
	int i;

	memcpy(palette, default_palette, sizeof(palette));

	memset(mode, 0, sizeof(mode));
	mode[DECANM] = true;
	mode[DECSCLM] = true;
	mode[DECARM] = true;
	mode[DECINLM] = true;
	mode[DECTCEM] = true;

	memset(&cursor, 0, sizeof(cursor));
	cursor.attrs = default_attrs;

	memset(tabstops, 0, screen_width * sizeof(bool));
	for (i = 8; i < screen_width; i += 8)
		tabstops[i] = true;

	for (i = 0; i < screen_height; i++)
		memset(lines[i], 0, LINE_SIZE(screen_width));

	saved_cursor = cursor;
	scroll_top = 0;
	scroll_bottom = screen_height - 1;
}

void
warpto(int x, int y)
{
	int miny, maxy;

	miny = mode[DECOM] ? scroll_top : 0;
	maxy = mode[DECOM] ? scroll_bottom : screen_height - 1;

	if (x < 0) x = 0; else if (x >= screen_width) x = screen_width - 1;
	if (y < miny) y = miny; else if (y > maxy) y = maxy;

	cursor.x = x;
	cursor.y = y;
	cursor.last_column = false;
}

void
scrollup()
{
	struct line *temp;

	memset((temp = lines[scroll_top]), 0, LINE_SIZE(screen_width));

	memmove(&lines[scroll_top], &lines[scroll_top + 1],
		(scroll_bottom - scroll_top) * sizeof(struct line *));

	lines[scroll_bottom] = temp;
}

void
scrolldown()
{
	struct line *temp;

	memset((temp = lines[scroll_bottom]), 0, LINE_SIZE(screen_width));

	memmove(&lines[scroll_top + 1], &lines[scroll_top],
		(scroll_bottom - scroll_top) * sizeof(struct line *));

	lines[scroll_top] = temp;
}

void
newline()
{
	cursor.last_column = false;

	if (cursor.y < scroll_bottom)
		cursor.y++;
	else
		scrollup();
}

void
putch(long ch)
{
	struct cell *cell;
	const unsigned char *glyph;
	int increment;

	if (cursor.last_column) {
		cursor.x = 0;
		newline();
	}

	cell = &lines[cursor.y]->cells[cursor.x];
	*cell = cursor.attrs;

	if (!cursor.conceal)
		cell->code_point = ch;

	increment = (glyph = find_glyph(ch)) && glyph[0] == '\2' ? 2 : 1;

	if (cursor.x + increment >= screen_width) {
		if (mode[DECAWM]) cursor.last_column = true;
	} else {
		cursor.x += increment;
	}
}