// screen.c - screen management routines
// Copyright (C) 2019 Megan Ruggiero. All rights reserved.
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#include <stdlib.h>
#include <string.h>
#include "terminix.h"

static const struct color default_palette[256] = {
	{0x00,0x00,0x00},{0x80,0x00,0x00},{0x00,0x80,0x00},{0x80,0x80,0x00},
	{0x00,0x00,0x80},{0x80,0x00,0x80},{0x00,0x80,0x80},{0xC0,0xC0,0xC0},
	{0x80,0x80,0x80},{0xFF,0x00,0x00},{0x00,0xFF,0x00},{0xFF,0xFF,0x00},
	{0x00,0x00,0xFF},{0xFF,0x00,0xFF},{0x00,0xFF,0xFF},{0xFF,0xFF,0xFF},
	{0x00,0x00,0x00},{0x00,0x00,0x5F},{0x00,0x00,0x87},{0x00,0x00,0xAF},
	{0x00,0x00,0xD7},{0x00,0x00,0xFF},{0x00,0x5F,0x00},{0x00,0x5F,0x5F},
	{0x00,0x5F,0x87},{0x00,0x5F,0xAF},{0x00,0x5F,0xD7},{0x00,0x5F,0xFF},
	{0x00,0x87,0x00},{0x00,0x87,0x5F},{0x00,0x87,0x87},{0x00,0x87,0xAF},
	{0x00,0x87,0xD7},{0x00,0x87,0xFF},{0x00,0xAF,0x00},{0x00,0xAF,0x5F},
	{0x00,0xAF,0x87},{0x00,0xAF,0xAF},{0x00,0xAF,0xD7},{0x00,0xAF,0xFF},
	{0x00,0xD7,0x00},{0x00,0xD7,0x5F},{0x00,0xD7,0x87},{0x00,0xD7,0xAF},
	{0x00,0xD7,0xD7},{0x00,0xD7,0xFF},{0x00,0xFF,0x00},{0x00,0xFF,0x5F},
	{0x00,0xFF,0x87},{0x00,0xFF,0xAF},{0x00,0xFF,0xD7},{0x00,0xFF,0xFF},
	{0x5F,0x00,0x00},{0x5F,0x00,0x5F},{0x5F,0x00,0x87},{0x5F,0x00,0xAF},
	{0x5F,0x00,0xD7},{0x5F,0x00,0xFF},{0x5F,0x5F,0x00},{0x5F,0x5F,0x5F},
	{0x5F,0x5F,0x87},{0x5F,0x5F,0xAF},{0x5F,0x5F,0xD7},{0x5F,0x5F,0xFF},
	{0x5F,0x87,0x00},{0x5F,0x87,0x5F},{0x5F,0x87,0x87},{0x5F,0x87,0xAF},
	{0x5F,0x87,0xD7},{0x5F,0x87,0xFF},{0x5F,0xAF,0x00},{0x5F,0xAF,0x5F},
	{0x5F,0xAF,0x87},{0x5F,0xAF,0xAF},{0x5F,0xAF,0xD7},{0x5F,0xAF,0xFF},
	{0x5F,0xD7,0x00},{0x5F,0xD7,0x5F},{0x5F,0xD7,0x87},{0x5F,0xD7,0xAF},
	{0x5F,0xD7,0xD7},{0x5F,0xD7,0xFF},{0x5F,0xFF,0x00},{0x5F,0xFF,0x5F},
	{0x5F,0xFF,0x87},{0x5F,0xFF,0xAF},{0x5F,0xFF,0xD7},{0x5F,0xFF,0xFF},
	{0x87,0x00,0x00},{0x87,0x00,0x5F},{0x87,0x00,0x87},{0x87,0x00,0xAF},
	{0x87,0x00,0xD7},{0x87,0x00,0xFF},{0x87,0x5F,0x00},{0x87,0x5F,0x5F},
	{0x87,0x5F,0x87},{0x87,0x5F,0xAF},{0x87,0x5F,0xD7},{0x87,0x5F,0xFF},
	{0x87,0x87,0x00},{0x87,0x87,0x5F},{0x87,0x87,0x87},{0x87,0x87,0xAF},
	{0x87,0x87,0xD7},{0x87,0x87,0xFF},{0x87,0xAF,0x00},{0x87,0xAF,0x5F},
	{0x87,0xAF,0x87},{0x87,0xAF,0xAF},{0x87,0xAF,0xD7},{0x87,0xAF,0xFF},
	{0x87,0xD7,0x00},{0x87,0xD7,0x5F},{0x87,0xD7,0x87},{0x87,0xD7,0xAF},
	{0x87,0xD7,0xD7},{0x87,0xD7,0xFF},{0x87,0xFF,0x00},{0x87,0xFF,0x5F},
	{0x87,0xFF,0x87},{0x87,0xFF,0xAF},{0x87,0xFF,0xD7},{0x87,0xFF,0xFF},
	{0xAF,0x00,0x00},{0xAF,0x00,0x5F},{0xAF,0x00,0x87},{0xAF,0x00,0xAF},
	{0xAF,0x00,0xD7},{0xAF,0x00,0xFF},{0xAF,0x5F,0x00},{0xAF,0x5F,0x5F},
	{0xAF,0x5F,0x87},{0xAF,0x5F,0xAF},{0xAF,0x5F,0xD7},{0xAF,0x5F,0xFF},
	{0xAF,0x87,0x00},{0xAF,0x87,0x5F},{0xAF,0x87,0x87},{0xAF,0x87,0xAF},
	{0xAF,0x87,0xD7},{0xAF,0x87,0xFF},{0xAF,0xAF,0x00},{0xAF,0xAF,0x5F},
	{0xAF,0xAF,0x87},{0xAF,0xAF,0xAF},{0xAF,0xAF,0xD7},{0xAF,0xAF,0xFF},
	{0xAF,0xD7,0x00},{0xAF,0xD7,0x5F},{0xAF,0xD7,0x87},{0xAF,0xD7,0xAF},
	{0xAF,0xD7,0xD7},{0xAF,0xD7,0xFF},{0xAF,0xFF,0x00},{0xAF,0xFF,0x5F},
	{0xAF,0xFF,0x87},{0xAF,0xFF,0xAF},{0xAF,0xFF,0xD7},{0xAF,0xFF,0xFF},
	{0xD7,0x00,0x00},{0xD7,0x00,0x5F},{0xD7,0x00,0x87},{0xD7,0x00,0xAF},
	{0xD7,0x00,0xD7},{0xD7,0x00,0xFF},{0xD7,0x5F,0x00},{0xD7,0x5F,0x5F},
	{0xD7,0x5F,0x87},{0xD7,0x5F,0xAF},{0xD7,0x5F,0xD7},{0xD7,0x5F,0xFF},
	{0xD7,0x87,0x00},{0xD7,0x87,0x5F},{0xD7,0x87,0x87},{0xD7,0x87,0xAF},
	{0xD7,0x87,0xD7},{0xD7,0x87,0xFF},{0xD7,0xAF,0x00},{0xD7,0xAF,0x5F},
	{0xD7,0xAF,0x87},{0xD7,0xAF,0xAF},{0xD7,0xAF,0xD7},{0xD7,0xAF,0xFF},
	{0xD7,0xD7,0x00},{0xD7,0xD7,0x5F},{0xD7,0xD7,0x87},{0xD7,0xD7,0xAF},
	{0xD7,0xD7,0xD7},{0xD7,0xD7,0xFF},{0xD7,0xFF,0x00},{0xD7,0xFF,0x5F},
	{0xD7,0xFF,0x87},{0xD7,0xFF,0xAF},{0xD7,0xFF,0xD7},{0xD7,0xFF,0xFF},
	{0xFF,0x00,0x00},{0xFF,0x00,0x5F},{0xFF,0x00,0x87},{0xFF,0x00,0xAF},
	{0xFF,0x00,0xD7},{0xFF,0x00,0xFF},{0xFF,0x5F,0x00},{0xFF,0x5F,0x5F},
	{0xFF,0x5F,0x87},{0xFF,0x5F,0xAF},{0xFF,0x5F,0xD7},{0xFF,0x5F,0xFF},
	{0xFF,0x87,0x00},{0xFF,0x87,0x5F},{0xFF,0x87,0x87},{0xFF,0x87,0xAF},
	{0xFF,0x87,0xD7},{0xFF,0x87,0xFF},{0xFF,0xAF,0x00},{0xFF,0xAF,0x5F},
	{0xFF,0xAF,0x87},{0xFF,0xAF,0xAF},{0xFF,0xAF,0xD7},{0xFF,0xAF,0xFF},
	{0xFF,0xD7,0x00},{0xFF,0xD7,0x5F},{0xFF,0xD7,0x87},{0xFF,0xD7,0xAF},
	{0xFF,0xD7,0xD7},{0xFF,0xD7,0xFF},{0xFF,0xFF,0x00},{0xFF,0xFF,0x5F},
	{0xFF,0xFF,0x87},{0xFF,0xFF,0xAF},{0xFF,0xFF,0xD7},{0xFF,0xFF,0xFF},
	{0x08,0x08,0x08},{0x12,0x12,0x12},{0x1C,0x1C,0x1C},{0x26,0x26,0x26},
	{0x30,0x30,0x30},{0x3A,0x3A,0x3A},{0x44,0x44,0x44},{0x4E,0x4E,0x4E},
	{0x58,0x58,0x58},{0x62,0x62,0x62},{0x6C,0x6C,0x6C},{0x76,0x76,0x76},
	{0x80,0x80,0x80},{0x8A,0x8A,0x8A},{0x94,0x94,0x94},{0x9E,0x9E,0x9E},
	{0xA8,0xA8,0xA8},{0xB2,0xB2,0xB2},{0xBC,0xBC,0xBC},{0xC6,0xC6,0xC6},
	{0xD0,0xD0,0xD0},{0xDA,0xDA,0xDA},{0xE4,0xE4,0xE4},{0xEE,0xEE,0xEE}
};

const uint32_t charset_united_kingdom[] = {
	0x000020, 0x000021, 0x000022, 0x0020AC, 0x000024, 0x000025, 0x000026,
	0x000027, 0x000028, 0x000029, 0x00002A, 0x00002B, 0x00002C, 0x00002D,
	0x00002E, 0x00002F, 0x000030, 0x000031, 0x000032, 0x000033, 0x000034,
	0x000035, 0x000036, 0x000037, 0x000038, 0x000039, 0x00003A, 0x00003B,
	0x00003C, 0x00003D, 0x00003E, 0x00003F, 0x000040, 0x000041, 0x000042,
	0x000043, 0x000044, 0x000045, 0x000046, 0x000047, 0x000048, 0x000049,
	0x00004A, 0x00004B, 0x00004C, 0x00004D, 0x00004E, 0x00004F, 0x000050,
	0x000051, 0x000052, 0x000053, 0x000054, 0x000055, 0x000056, 0x000057,
	0x000058, 0x000059, 0x00005A, 0x00005B, 0x00005C, 0x00005D, 0x00005E,
	0x00005F, 0x000060, 0x000061, 0x000062, 0x000063, 0x000064, 0x000065,
	0x000066, 0x000067, 0x000068, 0x000069, 0x00006A, 0x00006B, 0x00006C,
	0x00006D, 0x00006E, 0x00006F, 0x000070, 0x000071, 0x000072, 0x000073,
	0x000074, 0x000075, 0x000076, 0x000077, 0x000078, 0x000079, 0x00007A,
	0x00007B, 0x00007C, 0x00007D, 0x00007E, 0x00007F
};

const uint32_t charset_dec_graphics[] = {
	0x000020, 0x000021, 0x000022, 0x000023, 0x000024, 0x000025, 0x000026,
	0x000027, 0x000028, 0x000029, 0x00002A, 0x00002B, 0x00002C, 0x00002D,
	0x00002E, 0x00002F, 0x000030, 0x000031, 0x000032, 0x000033, 0x000034,
	0x000035, 0x000036, 0x000037, 0x000038, 0x000039, 0x00003A, 0x00003B,
	0x00003C, 0x00003D, 0x00003E, 0x00003F, 0x000040, 0x000041, 0x000042,
	0x000043, 0x000044, 0x000045, 0x000046, 0x000047, 0x000048, 0x000049,
	0x00004A, 0x00004B, 0x00004C, 0x00004D, 0x00004E, 0x00004F, 0x000050,
	0x000051, 0x000052, 0x000053, 0x000054, 0x000055, 0x000056, 0x000057,
	0x000058, 0x000059, 0x00005A, 0x00005B, 0x00005C, 0x00005D, 0x00005E,
	0x000000, 0x0025C6, 0x002592, 0x002409, 0x00240C, 0x00240D, 0x00240A,
	0x0000B0, 0x0000B1, 0x002424, 0x00240B, 0x002518, 0x002510, 0x00250C,
	0x002514, 0x00253C, 0x0023BA, 0x0023BB, 0x002500, 0x0023BC, 0x0023BD,
	0x00251C, 0x002524, 0x002534, 0x00252C, 0x002502, 0x002264, 0x002265,
	0x0003C0, 0x002260, 0x0000A3, 0x0000B7, 0x00007F
};

const struct cell default_attrs = {
	.background = {0, 0, 0},
	.foreground = {7, 0, 0}
};

struct color palette[256];
bool mode[MODE_COUNT];
struct cursor cursor, saved_cursor;
bool *tabstops;
struct line **lines;
short screen_width, screen_height, scroll_top, scroll_bottom;

void
deinit_screen()
{
	int i;

	for (i = 0; i < screen_height; i++)
		free(lines[i]);

	free(lines);
	free(tabstops);
}

void
resize(int width, int height)
{
	int i;

	deinit_screen();

	if (!(tabstops = calloc(width, sizeof(bool))))
		pdie("failed to allocate tab stop memory");

	for (i = 8; i < width; i += 8)
		tabstops[i] = true;

	if (!(lines = calloc(height, sizeof(struct line *))))
		pdie("failed to allocate line array memory");

	for (i = 0; i < height; i++)
		if (!(lines[i] = calloc(LINE_SIZE(width), 1)))
			pdie("failed to allocate line memory");

	screen_width = width;
	screen_height = height;
	scroll_top = 0;
	scroll_bottom = height - 1;
	cursor.x = 0;
	cursor.y = 0;
}

void
reset()
{
	int i;

	memcpy(palette, default_palette, sizeof(palette));

	memset(mode, 0, sizeof(mode));
	mode[DECANM] = true;
	mode[DECSCLM] = true;
	mode[DECARM] = true;
	mode[DECINLM] = true;
	mode[DECTCEM] = true;

	memset(&cursor, 0, sizeof(cursor));
	cursor.attrs = default_attrs;

	memset(tabstops, 0, screen_width * sizeof(bool));
	for (i = 8; i < screen_width; i += 8)
		tabstops[i] = true;

	for (i = 0; i < screen_height; i++)
		memset(lines[i], 0, LINE_SIZE(screen_width));

	saved_cursor = cursor;
	scroll_top = 0;
	scroll_bottom = screen_height - 1;
}

void
warpto(int x, int y)
{
	int miny, maxy;

	miny = mode[DECOM] ? scroll_top : 0;
	maxy = mode[DECOM] ? scroll_bottom : screen_height - 1;

	if (x < 0) x = 0; else if (x >= screen_width) x = screen_width - 1;
	if (y < miny) y = miny; else if (y > maxy) y = maxy;

	cursor.x = x;
	cursor.y = y;
	cursor.last_column = false;
}

void
scrollup()
{
	struct line *temp;

	memset((temp = lines[scroll_top]), 0, LINE_SIZE(screen_width));

	memmove(&lines[scroll_top], &lines[scroll_top + 1],
		(scroll_bottom - scroll_top) * sizeof(struct line *));

	lines[scroll_bottom] = temp;
}

void
scrolldown()
{
	struct line *temp;

	memset((temp = lines[scroll_bottom]), 0, LINE_SIZE(screen_width));

	memmove(&lines[scroll_top + 1], &lines[scroll_top],
		(scroll_bottom - scroll_top) * sizeof(struct line *));

	lines[scroll_top] = temp;
}

void
newline()
{
	cursor.last_column = false;

	if (cursor.y < scroll_bottom)
		cursor.y++;
	else
		scrollup();
}

void
revline()
{
	cursor.last_column = false;

	if (cursor.y > scroll_top)
		warpto(cursor.x, cursor.y - 1);
	else
		scrolldown();
}

void
putch(long ch)
{
	struct cell *cell;
	const uint32_t *charset;
	const unsigned char *glyph;
	int increment;

	if (cursor.last_column) {
		cursor.x = 0;
		newline();
	}

	cell = &lines[cursor.y]->cells[cursor.x];
	*cell = cursor.attrs;

	if (!cursor.conceal) {
		if (ch >= 0x20 && ch <= 0x7F &&
			(charset = cursor.charset[mode[SHIFT_OUT]]))
			ch = charset[ch - 0x20];

		cell->code_point = ch;
	}

	increment = (glyph = find_glyph(ch)) && glyph[0] == '\2' ? 2 : 1;

	if (cursor.x + increment >= screen_width) {
		if (mode[DECAWM]) cursor.last_column = true;
	} else {
		cursor.x += increment;
	}
}